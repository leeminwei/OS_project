-----

### **一個微型檔案系統 (A Tiny FileSystem)**

**變更：**
請依以下說明更新標頭檔 `TinyFS.h`：

  * 將 `#define MAX_FILES 400` 改為 `#define MAX_FILES 100`
  * 將 `#define MAX_OPEN_FILES 256` 改為 `#define MAX_OPEN_FILES 5`

**請勿**對所提供的檔案進行任何其他變更。

-----

### **目標**

本作業的目標是實作一個名為 `TinyFS` 的使用者層級檔案系統函式庫，它將模擬真實檔案系統的基本功能。您將學習到：

  * 檔案系統如何管理檔案並分配儲存空間。
  * 如何處理檔案系統中常見的效能挑戰。

### **閱讀材料**

[cite\_start]本專案涵蓋教科書第 39 章和第 40 章以及課程教材第 10.1 講和第 10.2 講的主題 [cite: 346, 348, 343, 344]。您的程式碼必須有適當的文件註解。請參閱評分標準 (rubric) 並閱讀 `code_style` 指南以了解文件要求。

-----

### **概覽**

[cite\_start]您的任務是建立 `TinyFS` 函式庫，讓應用程式能與檔案互動。此函式庫內部將與由 `TinyDisk` 模組提供的磁碟層互動。`TinyDisk` 層模擬了讀取和寫入資料區塊等磁碟操作 [cite: 389]。您需要修改 `TinyFs.c` 來實作檔案系統，並修改 `TinyFsApp.c` 來實作一些測試案例。請勿修改任何其他提供的程式碼。

### **提供的內容**

下載 `fs.zip`

  * **磁碟抽象層 (TinyDisk.c 和 TinyDisk.h):**
    您可能會問的第一個問題是「我該把所有檔案系統資料儲存在哪裡？」一個真正的檔案系統會將所有資料儲存在磁碟上，但由於我們是在使用者層級撰寫，我們將把它儲存在一個「虛擬」磁碟中。在 `TinyDisk.c` 和 `TinyDisk.h` 中，您會找到本次作業需要互動的「磁碟」。

    我們提供的「磁碟」有 `NUM_BLOCKS` 個區塊，每個區塊的大小為 `BLOCK_SIZE`。這些常數定義在 `TinyDisk.h` 中。因此，您需要在您的檔案系統結構中使用這些值。磁碟的模型非常簡單：檔案系統將執行磁碟讀取和磁碟寫入來讀或寫一個磁碟區塊。以下是提供給您的基本磁碟 API：

      * `int Disk_Init()`
        `Disk_Init()` 應在任何其他磁碟操作發生前由您的作業系統**呼叫一次**。

      * `int Disk_Load(char* file)`
        `Disk_Load()` 用於將檔案 `file` 中的檔案系統內容載入到記憶體中。此函式（以及之前的 `Disk_Init()`）很可能會在您的函式庫「啟動」時，即在 `FS_Boot()` 期間執行一次。

      * `int Disk_Save(char* file)`
        `Disk_Save()` 會將目前記憶體中的磁碟視圖儲存到名為 `file` 的檔案中。此函式將用於將您的「磁碟」內容儲存到一個真實檔案，以便您稍後可以再次從它「啟動」。此函式可能會由 `FS_Sync()` 呼叫。

      * `int Disk_Write(int blockIndex, char* buffer)`
        `Disk_Write()` 會將 `buffer` 中的資料寫入由 `block` 指定的區塊。緩衝區大小假定正好為一個區塊的大小。

      * `int Disk_Read(int blockIndex, char* buffer)`
        `Disk_Read()` 會將一個區塊的內容讀入由 `buffer` 指定的緩衝區。與 `Disk_Write()` 一樣，緩衝區大小假定正好為一個區塊的大小。

  * **起始程式碼：**

      * `TinyFs.h`: 包含您需要實作的函式原型的標頭檔 [請勿變更]。
      * `TinyFs.c`: 您將在此檔案中實作 `TinyFS` 函式庫 [您也可以撰寫一些輔助函式]。
      * `TinyFSApp.c`: 用於驗證您實作的測試應用程式。您是自己程式碼的最佳測試者。請撰寫一些測試案例來測試您的實作。建議進行增量測試。

  * **Makefile:**
    使用提供的 `Makefile` 來編譯您的程式碼並執行測試。

    ```bash
    make
    ./demo image_file
    make clean
    ```

-----

### **提交**

請提交包含您完成的 `TinyFs.c` 和 `TinyFsApp.c` 的完整 zip 檔案。請勿修改任何其他檔案，因為這可能導致在我們的系統上編譯失敗或輸出不正確。**您必須在 Ubuntu 上測試您的程式碼。** 提交在其他 UNIX 系統上測試的程式碼可能會導致不一致，我們將不為這些情況提供疑難排解支援或重新評分。無法編譯的程式碼或任何空白/錯誤的檔案提交將獲得 0 分。

-----

### **實作 TinyFS API**

您將在 `TinyFs.c` 中實作以下函式：

  * `int FS_Boot(char *path)`
    `FS_Boot()` 函式是初始化 `TinyFS` 系統的進入點，且必須在任何其他檔案系統操作之前僅呼叫一次。此函式接受一個參數 `path`，它指定了儲存磁碟映像檔的檔案路徑，或者一個尚不存在、必須被建立以容納新磁碟映像檔的檔案。成功時返回 0。失敗時返回 `E_DISK_ERROR`。

    如果磁碟檔案不存在，這意味著您應該建立一個新的磁碟。您應使用 `Disk_Init()`，接著進行幾次 `Disk_Write()` 操作來初始化磁碟，然後使用 `Disk_Save()` 將這些變更提交到磁碟。首先，您需要在磁碟的某處記錄一些關於檔案系統的通用資訊，這個區塊稱為**超級區塊 (superblock)**。它應該位於磁碟上一個眾所周知的位置——在此情況下，請將其設為第一個區塊。對於本作業，您不需要在那裡記錄太多資訊。事實上，您應該在超級區塊中只記錄一件事——一個**魔術數字 (magic number)**。選擇任何您喜歡的數字，當您初始化一個新的檔案系統時，將這個魔術數字寫入超級區塊。然後，當您再次使用同一個檔案系統啟動時，請確保當您讀取該超級區塊時，魔術數字存在。如果不存在，則假設這是一個損毀的檔案系統。

    接著，該函式為兩個點陣圖分配區塊：inode 點陣圖和資料區塊點陣圖。inode 點陣圖追蹤哪些 inodes（檔案的元資料區塊）正在使用，而資料區塊點陣圖追蹤儲存實際檔案資料的區塊的分配狀態。

    然後，函式初始化 inode 區塊。每個 inode 區塊儲存一個檔案的元資料，包括其名稱（最多 128 位元組）、檔案大小，以及一個包含 5 個整數的陣列，用於儲存資料區塊的索引。要設定此項，請在磁碟上為所有 inode 區塊分配空間。根據 inode 結構的大小和所需的 inodes 數量，使用 `Disk_Write` 函式將這些區塊寫入磁碟。

    接下來，函式初始化資料區塊。同樣地，使用 `Disk_Write` 為磁碟上所有資料區塊分配空間。請參考提供的常數來決定 inode 和資料區塊所需的大小和位置。最後，使用 `Disk_Save()` 將磁碟映像檔儲存到由 `path` 指定的檔案中。

    除了管理磁碟映像檔，`FS_Boot()` 還要確保**開啟檔案表 (Open File Table)** 已被初始化。每個檔案被分配一個從 0 開始的唯一檔案描述符，並且隨著新檔案的開啟，描述符會遞增。任何時候最多可以有 **5 個**開啟的檔案。當系統啟動時，開啟檔案表是空的，檔案描述符會在檔案被開啟時分配。

    如果由 `path` 指定的檔案存在，函式使用 `Disk_Load(path)` 將磁碟映像檔載入到記憶體中。載入後，函式執行關鍵的驗證步驟。首先，它確保檔案大小與預期的大小 `NUM_BLOCKS * BLOCK_SIZE` 相符。接著，它檢查磁碟第一個區塊的超級區塊，以驗證是否存在一個唯一標識該磁碟為有效 `TinyFS` 檔案系統的「魔術數字」。如果檔案大小不正確或超級區塊不包含預期的魔術數字，函式會假設磁碟已損毀並返回錯誤碼 `E_DISK_ERROR`。

  * `int File_Create(char *file)`
    `File_Create()` 建立一個由 `file` 指向的名稱的新檔案。如果檔案已存在，應返回 `E_FILE_EXISTS`。如果沒有可用的區塊來建立檔案，返回 `E_NO_SPACE`。建立檔案涉及在磁碟上分配一個 inode 區塊和資料區塊來代表該檔案，而不是在本地系統上建立一個實體檔案。成功建立後，函式應返回 `0`。

  * `int File_Open(char *file)`
    `File_Open()` 開啟一個檔案並返回一個整數檔案描述符（大於或等於 0 的數字），可用於讀取或寫入該檔案的資料。如果檔案不存在，返回 `E_NO_SUCH_FILE`。最多可開啟的檔案數為 **5**。如果已達到最大開啟檔案數，例如使用者想開啟第 6 個檔案，則返回 `E_TOO_MANY_OPEN_FILES`。

  * `int File_Read(int fd, void *buffer, int size)`
    `File_Read()` 應從檔案描述符 `fd` 所引用的檔案中讀取 `size` 個位元組。資料應讀入由 `buffer` 指向的緩衝區。所有讀取都應從目前檔案指標的位置開始，且檔案指標應在讀取後更新到新的位置。如果檔案未開啟，返回 `E_BAD_FD`。如果檔案已開啟，應返回實際讀取的位元組數，該數值可能小於或等於 `size`。該數值可能小於請求的位元組數，因為可能已到達檔案結尾。

  * `int File_Write(int fd, void *buffer, int size)`
    `File_Write()` 應從 `buffer` 中寫入 `size` 個位元組到由 `fd` 引用的檔案中。所有寫入都應從目前檔案指標的位置開始，且檔案指標應在寫入後更新為其目前位置加上 `size`。請注意，寫入是擴展檔案大小的唯一方法。如果檔案未開啟，返回 `E_BAD_FD`。寫入成功後，所有資料都應被寫出到磁碟，並返回 `size` 的值。如果寫入因空間不足而無法完成，返回 `E_NO_SPACE`。最後，如果檔案超過最大檔案大小，應返回 `E_FILE_TOO_BIG`。

  * **注意：** 當讀取或寫入檔案時，您需要實作一個**目前檔案指標 (current file pointer)** 的概念。這個概念很簡單：開啟檔案後，目前檔案指標設定在檔案的開頭（位元組 0）。如果使用者接著從檔案中讀取 N 個位元組，目前檔案指標應更新為 N。再次讀取 M 個位元組將返回從檔案偏移量 N 開始、最多到 N+M 位元組的資料。因此，透過重複呼叫讀取（或寫入），程式可以讀取（或寫入）整個檔案。

  * `int File_Close(int fd)`
    `File_Close()` 關閉由檔案描述符 `fd` 引用的檔案。如果檔案當前未開啟，返回 `E_BAD_FD`。成功時返回 0。

  * `int File_Delete(char *file)`
    此函式應刪除由 `file` 引用的檔案，清除 inode 點陣圖條目和資料點陣圖條目，釋放 inode 條目以及該檔案使用的任何資料區塊。如果檔案當前不存在，返回 `E_NO_SUCH_FILE`。如果檔案當前已開啟，返回 `E_FILE_IN_USE`（且**不要**刪除該檔案）。成功時返回 0。

-----

### **測試案例**

在 `TinyFSApp.c` 中實作數個測試案例。涵蓋建立檔案、開啟和關閉檔案，以及讀寫檔案等操作。請考慮並測試相關的邊界案例。

-----

### **僅限研究生：**

在真實的作業系統中，資料會頻繁地提交到磁碟以確保不會遺失。您需要實作當應用程式呼叫 `FS_Sync()` 函式時，將資料提交到磁碟。

  * `int FS_Sync()`
    `FS_Sync()` 函式確保所有在記憶體中對檔案系統的變更都被持久地寫入磁碟。此操作使檔案系統在系統關機或當機後能保持一致性並可恢復。使用 `Disk_Save()` 將磁碟狀態儲存到指定的檔案中。成功完成後，`FS_Sync()` 返回 `0`。如果在此過程中發生任何錯誤，應返回錯誤碼 `E_DISK_ERROR`。

  * `int File_Seek(int fd, int offset)`
    `File_Seek()` 函式用於更新給定檔案描述符的目前檔案指標位置。新位置由 `offset` 參數決定，該參數是從檔案開頭計算的。如果指定的 `offset` 大於檔案大小或是負數，`File_Seek()` 應返回錯誤碼 `E_SEEK_OUT_OF_BOUNDS`。如果提供的檔案描述符不對應於一個開啟的檔案，函式應返回 `E_BAD_FD`。成功時，`File_Seek()` 更新檔案指標並返回新的位置。

研究生必須實作至少五個測試案例來徹底測試 `File_Seek()`，其中至少包括兩個專門測試錯誤處理的邊界案例。
