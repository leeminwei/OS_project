# 記憶體分頁演算法比較程式

本專案實現並比較兩種常見的記憶體分頁替換演算法：
- **FIFO (First In First Out)** - 先進先出演算法
- **LRU (Least Recently Used)** - 最近最少使用演算法

## 專案檔案結構

```
Project_2nd_Version/
├── main.c          # 主程式，處理使用者輸入和輸出
├── fifo.h/fifo.c   # FIFO演算法實現
├── lru.h/lru.c     # LRU演算法實現
├── utils.h/utils.c # 共用工具函數
├── Makefile        # 編譯設定檔
└── README.md       # 說明檔案
```

## 編譯和執行

### 編譯專案
```bash
make
```

### 執行程式
```bash
make run
```
或
```bash
./page_replacement
```

### 清理編譯檔案
```bash
make clean
```

## 程式使用說明

程式會依序要求使用者輸入：

1. **k個可儲存片段數量**：記憶體中可以存放的頁面框架數量
2. **i個頁面請求數量**：要處理的頁面請求總數
3. **頁面請求序列**：i個頁面編號

## 測試範例

### 範例 1
```
輸入：
k = 3 (3個記憶體框架)
i = 7 (7個頁面請求)
頁面序列：7 0 1 2 0 3 0

預期結果：
FIFO會產生較多頁面錯誤，因為不考慮頁面的使用頻率
LRU會產生較少頁面錯誤，因為會保留最近使用的頁面
```

### 範例 2 (Belady異常現象)
```
輸入：
k = 3
i = 12
頁面序列：1 2 3 4 1 2 5 1 2 3 4 5

這個例子可能會展示Belady異常現象，即增加記憶體框架數量反而增加頁面錯誤次數
```

### 範例 3 (簡單測試)
```
輸入：
k = 2
i = 6
頁面序列：1 2 3 1 2 3

這是一個簡單的測試案例，便於手動驗證演算法正確性
```

## 演算法說明

### FIFO (先進先出)
- 總是替換最早進入記憶體的頁面
- 實現簡單，使用環形隊列追蹤頁面順序
- 可能發生Belady異常現象

### LRU (最近最少使用)
- 替換最長時間未被使用的頁面
- 需要追蹤每個頁面的最後使用時間
- 通常比FIFO有更好的效能

## 程式輸出

程式會顯示：
1. 兩種演算法的詳細執行過程
2. 每一步的記憶體框架狀態
3. 頁面命中/錯誤情況
4. 最終的頁面錯誤次數和錯誤率比較
5. 哪種演算法表現較佳

## 學習目標

通過此專案，學生可以：
1. 理解記憶體分頁管理的基本概念
2. 實現和比較不同的頁面替換演算法
3. 觀察演算法在不同輸入下的表現差異
4. 學習C語言程式設計和模組化開發

## 擴展建議

可以進一步實現：
1. **Optimal演算法**：未來最長時間不會使用的頁面
2. **Clock演算法**：FIFO的改進版本
3. **圖形化界面**：視覺化演算法執行過程
4. **效能分析**：測試大量隨機數據的演算法效能 